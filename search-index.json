[{"documents":[{"i":1,"t":"如何使用CRDT实现一个简单的多人文本协同应用","u":"/blog/2022/07/25/crdt-toy","b":["Blog"]},{"i":11,"t":"","u":"/blog/archive","b":["Blog"]}],"index":{"version":"2.3.9","fields":["t"],"fieldVectors":[["t/1",[0,0.492]],["t/11",[]]],"invertedIndex":[["crdt",{"_index":0,"t":{"1":{"position":[[0,23]]}}}]],"pipeline":["stemmer"]}},{"documents":[{"i":3,"t":"什么是CRDTs","u":"/blog/2022/07/25/crdt-toy","h":"#什么是crdts","p":1},{"i":5,"t":"CRDTs的简单实现","u":"/blog/2022/07/25/crdt-toy","h":"#crdts的简单实现","p":1},{"i":7,"t":"分布式中的顺序","u":"/blog/2022/07/25/crdt-toy","h":"#分布式中的顺序","p":1},{"i":9,"t":"只确定逻辑顺序就够了吗","u":"/blog/2022/07/25/crdt-toy","h":"#只确定逻辑顺序就够了吗","p":1}],"index":{"version":"2.3.9","fields":["t"],"fieldVectors":[["t/3",[0,0.693]],["t/5",[0,0.693]],["t/7",[1,0.693]],["t/9",[1,0.693]]],"invertedIndex":[["",{"_index":1,"t":{"7":{"position":[[0,7]]},"9":{"position":[[0,11]]}}}],["crdt",{"_index":0,"t":{"3":{"position":[[0,8]]},"5":{"position":[[0,10]]}}}]],"pipeline":["stemmer"]}},{"documents":[{"i":2,"t":"这篇博客将简要介绍CRDTs（Conflict-free Replicated Data Types）的基本概念以及从开发者的角度着重介绍简单的CRDTs的实现流程与细节（基于RGA算法），并且基于这些知识点实现一个rust+wasm的简单web文本协作demo。 项目地址: https://github.com/Leeeon233/crdt-toy demo地址: https://leonzhao.cn/crdt-toy","s":"如何使用CRDT实现一个简单的多人文本协同应用","u":"/blog/2022/07/25/crdt-toy","h":"","p":1},{"i":4,"t":"对于CRDTs可以优先通过看[CRDT简介]、[CRDT原理]这些文章了解。 CRDTs是近些年开始备受关注的一种用来处理分布式系统上的协同可用性的数据结构。它在可用性与分区容错性的基础上，不提供完美的一致性而是提供强最终一致性。下面的例子可以帮助我们理解什么是强最终一致性。 比如当前有Alice和Bob两个同学在各自的电脑上共同编辑同一份文档，Alice写入了Hello CRDT，Bob写入了Hello crdt。 但在此时Alice其实并没有办法知晓Bob可能在同一时刻也写入了Hello crdt的文本，并不像真正本地那样，完全意义上的在编辑同一份文件（一致性）。 只有当他们进行了一次同步通信后，Alice或者Bob才会知晓对方编辑了什么。crdt所提供的强最终一致性意义并不是让多人协同真正地像大家就在同一页纸上写字一样，而是大家可以各自地编辑自己的内容，尽管在多次同步的过程中会产生冲突，但crdt可以保证所有的消息都被接收后，最终的内容将会是多方一致的，哪怕可能最终冲突解决后的版本并不是真正所期待的结果。 对于Alice和Bob的例子，在输入Hello CRDT和Hello crdt时可能进行了多次的同步操作，最终展现在Alice和Bob眼前的文本根据不同的crdt算法和冲突解决策略可能变得不同。也许是Hello crdt、Hello CRDTHellocrdt或Hello CRDTcrdt等等都有可能，但是最终在Alice和Bob眼前的结果将会是完全一致的其中一种结果。","s":"什么是CRDTs","u":"/blog/2022/07/25/crdt-toy","h":"#什么是crdts","p":1},{"i":6,"t":"我们就以多人的文本内容协作作为场景来尝试实现一个基于op的crdt的编辑器。下面是编辑器demo的效果展示。分别有Client1和Client2两个客户端在共同编辑一份文档。 Final Text的文本区域展示的当前同步后的结果。Client1和Client2也可以点击按钮表示进行同步。 首先我们需要确定这样一个简单的编辑器，用户会有哪些操作(op)。思考一下，非常简单地就可以得出一共有两种操作： 插入 删除 修改（可以简单地视为先删除再插入的组合）","s":"CRDTs的简单实现","u":"/blog/2022/07/25/crdt-toy","h":"#crdts的简单实现","p":1},{"i":8,"t":"那么我们还是回到Alice和Bob的例子，我们提供了第一版的编辑器给他们，但是由于我们技术还未成熟，要求他们只能插入内容还不能删除。Alice和Bob同意参与到我们的迭代测试中去。他们还是分别一次输入了 Hello CRDT和Hello crdt。这时他们发起了同步。 Alice给Bob打了个电话，发现自己的屏幕上结果是Hello CRDTHello crdt而Bob的屏幕上结果是Hello crdtHello CRDT。怎么会这样？他们把测试结果反馈给了我们。 原来我们第一版系统都把新接收到的插入操作当作了后发生的事情，Alice的编辑器把Bob的内容加在了后面，Bob的编辑器也是如此。这和我们一开始所强调的强最终一致性可不符。我们希望无论事件被怎样创建和接收，只要操作集合是一致的，那么最终结果应该一样。 既然已经知道了问题所在，那么就没什么问题了。我们只需要让每个用户之间有一个固定的顺序就可以了，可以为每一个编辑器客户端分配一个Client ID，以ID的大小顺序来作为操作的顺序。我们很快发布了v2.0版本，让客户端ID越大认为操作越先发生，并且分配 Alice的客户端版本为1 Bob的客户端版本为2 提供给了Alice和Bob帮忙测试使用。 这回没有问题了，Alice和Bob的编辑器上显示的都是Hello crdtHello CRDT文本。 但随着进一步使用，Alice和Bob又发现问题了。这次 Bob 先输入了one 然后又输入了two Alice先输入了three 又输入了four 然后他们进行了同步，这次每个人都发送了两个插入操作。 现在Bob的屏幕上显示的是one two fourthree 而Alice屏幕上显示的却是one two three four，正常来说one two three four才是他们想要的结果。 我们发现Alice向Bob同步的内容发生了顺序的改变，有着分布式经验的我们立刻想到，可能是网络延迟的原因，导致Alice的第二个操作早于第一个操作被Bob的客户端接收到造成了顺序的不一致。 既然已经知道了问题所在，那么就没什么问题了。我们可以新增一个逻辑时间戳，也就是Lamport Timestamp Lamport Timestamp 的算法很简单1 每个进程维护一个counter 本地每发生一个事件就将counter + 1，并将事件的时间戳设置为counter值 每当进程发送一个消息，就将本地counter + 1，并将最新的counter值附带在消息上 当进程收到消息后，让自己的counter = max(counter, message.counter) + 1 我们在原有的ClientId基础上进行了扩展，构建了一个EventId，其中包括了ClientId和Lamport Timestamp两部分，这样事件的发生顺序就可以与接收到的顺序无关了。 我们抓紧更新了v3.0版本的编辑器给到Alice和Bob，心想肯定没问题了。","s":"分布式中的顺序","u":"/blog/2022/07/25/crdt-toy","h":"#分布式中的顺序","p":1},{"i":10,"t":"如何设计 CRDT 算法-Zxch3n↩","s":"只确定逻辑顺序就够了吗","u":"/blog/2022/07/25/crdt-toy","h":"#只确定逻辑顺序就够了吗","p":1}],"index":{"version":"2.3.9","fields":["t"],"fieldVectors":[["t/2",[0,1.665,1,1.665,2,1.665,3,1.665,4,1.665,5,0.345,6,1.665,7,2.154,8,1.665,9,1.665]],["t/4",[10,1.542,11,0.894,12,1.542,13,1.542,14,1.542,15,1.542,16,1.542,17,0.974,18,1.542,19,1.542,20,1.542,21,1.542]],["t/6",[5,0.522,22,1.861,23,1.861,24,1.861,25,1.861]],["t/8",[5,0.393,11,0.587,17,0.475,26,0.752,27,0.752,28,0.752,29,1.51,30,0.752,31,0.752,32,0.752,33,0.752,34,0.752,35,0.752,36,1.206,37,0.752,38,0.752,39,0.752,40,1.728,41,0.752,42,1.206,43,0.752,44,0.752,45,0.752,46,1.206,47,0.752,48,0.752,49,1.206,50,1.51,51,1.206,52,1.728,53,0.752,54,0.752,55,0.752,56,0.752,57,0.752,58,0.752]],["t/10",[5,0.508,11,0.794,59,2.042]]],"invertedIndex":[["",{"_index":5,"t":{"2":{"position":[[133,5]]},"6":{"position":[[201,2],[204,2],[207,20]]},"8":{"position":[[657,26],[994,1],[1041,1],[1086,1],[1118,1]]},"10":{"position":[[0,4],[10,2]]}}}],["1",{"_index":51,"t":{"8":{"position":[[951,7],[1120,1]]}}}],["1，并将事件的时间戳设置为counter",{"_index":53,"t":{"8":{"position":[[996,21]]}}}],["1，并将最新的counter",{"_index":54,"t":{"8":{"position":[[1043,21]]}}}],["alice先输入了thre",{"_index":41,"t":{"8":{"position":[[633,14]]}}}],["alice其实并没有办法知晓bob可能在同一时刻也写入了hello",{"_index":14,"t":{"4":{"position":[[211,37]]}}}],["alice向bob同步的内容发生了顺序的改变，有着分布式经验的我们立刻想到，可能是网络延迟的原因，导致alice的第二个操作早于第一个操作被bob",{"_index":48,"t":{"8":{"position":[[781,94]]}}}],["alice和bob",{"_index":36,"t":{"8":{"position":[[511,20],[583,27]]}}}],["alice和bob两个同学在各自的电脑上共同编辑同一份文档，alice写入了hello",{"_index":12,"t":{"4":{"position":[[139,48]]}}}],["alice和bob的例子，在输入hello",{"_index":16,"t":{"4":{"position":[[463,23]]}}}],["alice和bob的例子，我们提供了第一版的编辑器给他们，但是由于我们技术还未成熟，要求他们只能插入内容还不能删除。alice和bob",{"_index":26,"t":{"8":{"position":[[0,101]]}}}],["alice和bob的编辑器上显示的都是hello",{"_index":37,"t":{"8":{"position":[[532,32]]}}}],["alice屏幕上显示的却是on",{"_index":45,"t":{"8":{"position":[[715,17]]}}}],["alice或者bob才会知晓对方编辑了什么。crdt所提供的强最终一致性意义并不是让多人协同真正地像大家就在同一页纸上写字一样，而是大家可以各自地编辑自己的内容，尽管在多次同步的过程中会产生冲突，但crdt",{"_index":15,"t":{"4":{"position":[[288,174]]}}}],["alice的客户端版本为1",{"_index":34,"t":{"8":{"position":[[485,13]]}}}],["alice的编辑器把bob的内容加在了后面，bob",{"_index":31,"t":{"8":{"position":[[234,124]]}}}],["alice给bob打了个电话，发现自己的屏幕上结果是hello",{"_index":28,"t":{"8":{"position":[[135,31]]}}}],["bob",{"_index":38,"t":{"8":{"position":[[611,3]]}}}],["bob的客户端版本为2",{"_index":35,"t":{"8":{"position":[[499,11]]}}}],["bob的屏幕上显示的是on",{"_index":43,"t":{"8":{"position":[[684,16]]}}}],["client",{"_index":32,"t":{"8":{"position":[[359,69]]}}}],["clientid基础上进行了扩展，构建了一个eventid，其中包括了clientid和lamport",{"_index":57,"t":{"8":{"position":[[1122,57]]}}}],["counter",{"_index":52,"t":{"8":{"position":[[959,15],[975,18],[1018,22],[1065,20]]}}}],["crdt",{"_index":11,"t":{"4":{"position":[[39,99],[205,5],[249,38]]},"8":{"position":[[119,15],[208,25],[575,7]]},"10":{"position":[[5,4]]}}}],["crdtcrdt等等都有可能，但是最终在alice和bob",{"_index":21,"t":{"4":{"position":[[600,49]]}}}],["crdthello",{"_index":29,"t":{"8":{"position":[[167,9],[198,9],[565,9]]}}}],["crdthellocrdt或hello",{"_index":20,"t":{"4":{"position":[[580,19]]}}}],["crdts可以优先通过看[crdt简介]、[crdt",{"_index":10,"t":{"4":{"position":[[0,38]]}}}],["crdts（conflict",{"_index":0,"t":{"2":{"position":[[0,23]]}}}],["crdt、hello",{"_index":19,"t":{"4":{"position":[[569,10]]}}}],["crdt和hello",{"_index":17,"t":{"4":{"position":[[487,10]]},"8":{"position":[[108,10]]}}}],["crdt时可能进行了多次的同步操作，最终展现在alice和bob眼前的文本根据不同的crdt算法和冲突解决策略可能变得不同。也许是hello",{"_index":18,"t":{"4":{"position":[[498,70]]}}}],["crdt而bob的屏幕上结果是hello",{"_index":30,"t":{"8":{"position":[[177,20]]}}}],["crdt，bob写入了hello",{"_index":13,"t":{"4":{"position":[[188,16]]}}}],["data",{"_index":3,"t":{"2":{"position":[[40,4]]}}}],["demo",{"_index":8,"t":{"2":{"position":[[177,7]]}}}],["final",{"_index":23,"t":{"6":{"position":[[88,5]]}}}],["four",{"_index":42,"t":{"8":{"position":[[648,8],[766,14]]}}}],["fourthre",{"_index":44,"t":{"8":{"position":[[705,9]]}}}],["four，正常来说on",{"_index":47,"t":{"8":{"position":[[743,12]]}}}],["free",{"_index":1,"t":{"2":{"position":[[24,4]]}}}],["hello",{"_index":27,"t":{"8":{"position":[[102,5]]}}}],["https://github.com/leeeon233/crdt",{"_index":6,"t":{"2":{"position":[[139,33]]}}}],["https://leonzhao.cn/crdt",{"_index":9,"t":{"2":{"position":[[185,24]]}}}],["id，以id的大小顺序来作为操作的顺序。我们很快发布了v2.0版本，让客户端id",{"_index":33,"t":{"8":{"position":[[429,55]]}}}],["lamport",{"_index":49,"t":{"8":{"position":[[876,46],[933,7]]}}}],["max(count",{"_index":55,"t":{"8":{"position":[[1088,12]]}}}],["message.count",{"_index":56,"t":{"8":{"position":[[1101,16]]}}}],["on",{"_index":39,"t":{"8":{"position":[[615,7]]}}}],["op",{"_index":25,"t":{"6":{"position":[[145,55]]}}}],["op的crdt的编辑器。下面是编辑器demo的效果展示。分别有client1和client2",{"_index":22,"t":{"6":{"position":[[0,87]]}}}],["replic",{"_index":2,"t":{"2":{"position":[[29,10]]}}}],["text的文本区域展示的当前同步后的结果。client1和client2",{"_index":24,"t":{"6":{"position":[[94,50]]}}}],["three",{"_index":46,"t":{"8":{"position":[[737,5],[760,5]]}}}],["timestamp",{"_index":50,"t":{"8":{"position":[[923,9],[941,9],[1180,36]]}}}],["toy",{"_index":7,"t":{"2":{"position":[[173,3],[210,3]]}}}],["two",{"_index":40,"t":{"8":{"position":[[623,9],[701,3],[733,3],[756,3]]}}}],["types）的基本概念以及从开发者的角度着重介绍简单的crdts的实现流程与细节（基于rga算法），并且基于这些知识点实现一个rust+wasm的简单web文本协作demo",{"_index":4,"t":{"2":{"position":[[45,87]]}}}],["v3.0版本的编辑器给到alice和bob",{"_index":58,"t":{"8":{"position":[[1217,38]]}}}],["zxch3n",{"_index":59,"t":{"10":{"position":[[13,7]]}}}]],"pipeline":["stemmer"]}}]